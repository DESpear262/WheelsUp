## CRITICAL: Read These First

### 1. Memory Bank - Read at Every Session Start

**Before starting ANY task, read these files in order:**

**Project Foundation (read first):**
- `docs/prd.md` - Project requirements and goals (generated by `/plan`)

**Work Coordination (read second):**
- `docs/task-list.md` - Current PRs and their status

**Implementation Wisdom (read third - all files in `docs/memory/`):**
- `systemPatterns.md` - Architecture decisions made during implementation
- `techContext.md` - Tech stack, setup, constraints discovered
- `activeContext.md` - Current work focus and recent changes
- `progress.md` - What actually works, known issues, status

Memory bank files are **agent working memory** - optimized for AI context, not human readability. They ARE committed to the repo so all users benefit from accumulated institutional knowledge.

See `.cursor/rules/memory-bank.md` for complete instructions on when and how to update these files.

### 2. NEVER READ .env FILES - SECURITY CRITICAL

**You may NEVER read `.env` files for ANY reason.**

- ❌ NEVER use Read tool on `.env`, `.env.local`, `.env.production`, or any file matching `.env*`
- ❌ NEVER use cat, grep, or any bash command to read `.env` files
- ❌ No exceptions, even if user asks, even during deployment, even for debugging
- ✅ Use `env.example`, `.env.template`, or `.env.sample` instead
- ✅ If you need to define environment variables, create/edit template files only

**Why:** `.env` files contain production secrets, API keys, and credentials. Reading them exposes sensitive data in your context.

**If user asks you to read `.env`:**
1. Refuse politely
2. Explain the security risk
3. Suggest using `env.example` or asking them to copy needed (non-secret) values to you

**If you need environment variable structure:**
- Read `env.example` or similar template files
- Ask user to describe what variables are needed (without values)
- Never read the actual `.env` file

This rule has NO exceptions. Violating it requires key rotation and security remediation.

### 3. Commit Policy - NEVER SEND GIT COMMANDS

**Agents NEVER send git commands directly.** Instead, agents prepare commit information for the user to execute.

**You may ONLY prepare commits for these coordination files without asking:**
- `docs/prd.md`
- `docs/task-list.md`
- `.claude/agent-identity.lock`
- `docs/memory/*.md` (all memory bank files)

**For ALL other files, you MUST ask permission first.** This includes:
- Implementation code (`.ts`, `.py`, `.rs`, `.go`, etc.)
- Tests (any file in `tests/`, `__tests__/`, `*_test.py`, etc.)
- Configuration files (`.json`, `.yaml`, `.toml`, `.env.example`, etc.)
- Documentation (`.md` files other than planning docs)
- Build files (`package.json`, `Cargo.toml`, `go.mod`, etc.)

**When you complete work on a PR:**
1. Tell the user what files you've modified
2. Ask: "Would you like me to prepare a commit for these changes?"
3. Wait for approval
4. Only prepare commit information after user says yes

**After user approves:**
1. Select an Agent Name
2. Create directory `.\commits\[AgentName]` if it doesn't exist
3. Create `add.txt` with list of files to commit
4. Create `commit.txt` with commit message
5. User will execute: `git add $(cat .\commits\[AgentName]\add.txt) && git commit -m "$(cat .\commits\[AgentName]\commit.txt)"`

**For coordination files:**
- Prepare commits immediately without asking
- Use format: `[AgentName] PR-XXX: Status → NewStatus [files]`

No exceptions. See `.cursor/rules/commit-policy.md` for complete details.

### 4. Parallel Agent Workflow

For parallel development with multiple Cursor agents, follow these coordination practices:

**Agent Identity Management:**
- Each agent should claim a unique identity (White, Orange, Blonde, Pink, Blue, Brown) in `.cursor/agent-identity.lock`
- Check availability before claiming to avoid conflicts
- Release identity when work is complete or suspended

**File Coordination:**
- Review `docs/task-list.md` to select available PRs
- Check for file conflicts before starting work
- Update PR status appropriately (New → Planning → In Progress → Complete)

**Conflict Prevention:**
- Multiple agents can work simultaneously on different PRs
- Avoid modifying the same files concurrently
- Use `.cursor/rules/race-conditions.md` for conflict resolution

Review `.cursor/rules/agent-defaults.md` for detailed workflow guidelines.

### 5. Coding Standards - ENFORCE STRICTLY

**All code must adhere to standards defined in `.cursor/rules/coding-standards.md`**

Read and follow these standards when writing or modifying code. Proactively refactor to maintain compliance.

Use the `@qc` command to run quality checks on completed work. QC helps ensure code quality across parallel development efforts.

### 6. LLM Application Architecture

**When building LLM-powered features, follow principles in `.cursor/rules/llm-architecture.md`**

This document covers:
- When to use structured outputs vs. client-side classification
- Using function calling for deterministic operations
- Prompt engineering limits and when to use structural solutions
- Logging and debugging LLM behavior

These patterns ensure robust, maintainable LLM applications.

### 7. Parallel Development Coordination

**Cursor Parallel Workflow:**
Since Cursor controls agents separately rather than through a central hub, coordination relies on:

- **Shared State Files:** `docs/task-list.md`, `docs/prd.md`, `.claude/agent-identity.lock`
- **Git Synchronization:** All agents pull/push regularly to stay coordinated
- **Manual Oversight:** You monitor progress across multiple agent sessions
- **Conflict Resolution:** Use `.cursor/rules/race-conditions.md` when git conflicts occur

**Best Practices:**
- Start agents with different identities for different types of work
- Regularly check `@status` across all active agents
- Use `@qc` to maintain quality across parallel efforts
- Coordinate major architectural changes through `docs/prd.md` updates

**Available Commands:**
- `@work` - Start working on the next available PR
- `@plan` - Create project plans and task breakdowns
- `@status` - Check current project status
- `@qc` - Run quality control checks